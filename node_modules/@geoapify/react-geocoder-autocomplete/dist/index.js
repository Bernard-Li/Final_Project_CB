function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var geocoderAutocomplete = require('@geoapify/geocoder-autocomplete');

var GeoapifyApiKey = React__default.createContext("");
var GeoapifyContext = function GeoapifyContext(props) {
  return React__default.createElement(GeoapifyApiKey.Provider, {
    value: props.apiKey
  }, props.children);
};
var GeoapifyGeocoderAutocomplete = function GeoapifyGeocoderAutocomplete(_ref) {
  var placeholderValue = _ref.placeholder,
      typeValue = _ref.type,
      langValue = _ref.lang,
      limitValue = _ref.limit,
      valueValue = _ref.value,
      filterByCountryCodeValue = _ref.filterByCountryCode,
      filterByCircleValue = _ref.filterByCircle,
      filterByRectValue = _ref.filterByRect,
      biasByCountryCodeValue = _ref.biasByCountryCode,
      biasByCircleValue = _ref.biasByCircle,
      biasByRectValue = _ref.biasByRect,
      biasByProximityValue = _ref.biasByProximity,
      positionValue = _ref.position,
      countryCodesValue = _ref.countryCodes,
      skipIconsValue = _ref.skipIcons,
      skipDetailsValue = _ref.skipDetails,
      preprocessHookValue = _ref.preprocessHook,
      postprocessHookValue = _ref.postprocessHook,
      suggestionsFilterValue = _ref.suggestionsFilter,
      placeSelectCallback = _ref.placeSelect,
      suggestionsChangeCallback = _ref.suggestionsChange,
      userInputCallback = _ref.onUserInput,
      openCallback = _ref.onOpen,
      closeCallback = _ref.onClose;
  var apiKey = React__default.useContext(GeoapifyApiKey);
  var geocoderContainer;
  var initialized = false;
  var geocoderAutocomplete$1 = React.useRef();
  var placeSelectCallbackRef = React.useRef();
  var suggestionsChangeCallbackRef = React.useRef();
  var userInputCallbackRef = React.useRef();
  var openCallbackRef = React.useRef();
  var closeCallbackRef = React.useRef();
  placeSelectCallbackRef.current = placeSelectCallback;
  suggestionsChangeCallbackRef.current = suggestionsChangeCallback;
  userInputCallbackRef.current = userInputCallback;
  openCallbackRef.current = openCallback;
  closeCallbackRef.current = closeCallback;
  var onSelect = React__default.useCallback(function (value) {
    if (placeSelectCallbackRef.current) {
      placeSelectCallbackRef.current(value);
    }
  }, []);
  var onSuggestions = React__default.useCallback(function (value) {
    if (suggestionsChangeCallbackRef.current) {
      suggestionsChangeCallbackRef.current(value);
    }
  }, []);
  var onUserInput = React__default.useCallback(function (input) {
    if (userInputCallbackRef.current) {
      userInputCallbackRef.current(input);
    }
  }, []);
  var onOpen = React__default.useCallback(function (opened) {
    if (openCallbackRef.current) {
      openCallbackRef.current(opened);
    }
  }, []);
  var onClose = React__default.useCallback(function (opened) {
    if (closeCallbackRef.current) {
      closeCallbackRef.current(opened);
    }
  }, []);
  React.useEffect(function () {
    if (initialized) {
      if (geocoderAutocomplete$1.current) {
        geocoderAutocomplete$1.current.off("select", onSelect);
        geocoderAutocomplete$1.current.off("suggestions", onSuggestions);
        geocoderAutocomplete$1.current.off("input", onUserInput);
        geocoderAutocomplete$1.current.off("close", onClose);
        geocoderAutocomplete$1.current.off("open", onOpen);
      }

      return;
    }

    initialized = true;
    geocoderAutocomplete$1.current = new geocoderAutocomplete.GeocoderAutocomplete(geocoderContainer, apiKey, {
      placeholder: placeholderValue || "",
      skipDetails: skipDetailsValue,
      skipIcons: skipIconsValue
    });
    geocoderAutocomplete$1.current.on("select", onSelect);
    geocoderAutocomplete$1.current.on("suggestions", onSuggestions);
    geocoderAutocomplete$1.current.on("input", onUserInput);
    geocoderAutocomplete$1.current.on("close", onClose);
    geocoderAutocomplete$1.current.on("open", onOpen);
  }, []);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setType(typeValue);
    }
  }, [typeValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setLang(langValue);
    }
  }, [langValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
      geocoderAutocomplete$1.current.addBiasByProximity(positionValue);
    }
  }, [positionValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
      geocoderAutocomplete$1.current.addFilterByCountry(countryCodesValue);
    }
  }, [countryCodesValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setLimit(limitValue);
    }
  }, [limitValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setValue(valueValue || "");
    }
  }, [valueValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addFilterByCountry(filterByCountryCodeValue);
    }
  }, [filterByCountryCodeValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addFilterByCircle(filterByCircleValue);
    }
  }, [filterByCircleValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addFilterByRect(filterByRectValue);
    }
  }, [filterByRectValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addBiasByCountry(biasByCountryCodeValue);
    }
  }, [biasByCountryCodeValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addBiasByCircle(biasByCircleValue);
    }
  }, [biasByCircleValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addBiasByRect(biasByRectValue);
    }
  }, [biasByRectValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.addBiasByProximity(biasByProximityValue);
    }
  }, [biasByProximityValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setPreprocessHook(preprocessHookValue);
    }
  }, [preprocessHookValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setPostprocessHook(postprocessHookValue);
    }
  }, [postprocessHookValue]);
  React.useEffect(function () {
    if (geocoderAutocomplete$1.current) {
      geocoderAutocomplete$1.current.setSuggestionsFilter(suggestionsFilterValue);
    }
  }, [suggestionsFilterValue]);
  return React__default.createElement("div", {
    className: "geocoder-container",
    style: {
      position: "relative"
    },
    ref: function ref(el) {
      return geocoderContainer = el;
    }
  });
};

exports.GeoapifyApiKey = GeoapifyApiKey;
exports.GeoapifyContext = GeoapifyContext;
exports.GeoapifyGeocoderAutocomplete = GeoapifyGeocoderAutocomplete;
//# sourceMappingURL=index.js.map
